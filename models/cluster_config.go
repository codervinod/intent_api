package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// ClusterConfig Cluster Configuration
//
// Cluster Configuration
// swagger:model cluster_config
type ClusterConfig struct {

	// build
	// Read Only: true
	Build *BuildInfo `json:"build,omitempty"`

	// List of cluster trusted CA certificates
	// Read Only: true
	CaCerts []*CaCert `json:"ca_certs,omitempty"`

	// certification signing info
	CertificationSigningInfo *CertificationSigningInfo `json:"certification_signing_info,omitempty"`

	// client auth
	ClientAuth *ClientAuth `json:"client_auth,omitempty"`

	// Percentage of the disk capacity that can have fingerprints in the
	// extent group metadata to be used by the content cache
	//
	ContentCacheFingerprintPercentage int32 `json:"content_cache_fingerprint_percentage,omitempty"`

	// Array of enabled features
	EnabledFeatures []string `json:"enabled_features,omitempty"`

	// encryption status
	EncryptionStatus *EncryptionStatus `json:"encryption_status,omitempty"`

	// List of cluster key management server
	KeyManagementServers []*KeyManagementServer `json:"key_management_servers,omitempty"`

	// List of valid ssh keys for the cluster
	PublicKeys []*PublicKey `json:"public_keys,omitempty"`

	// Cluster supported redundancy factor
	RedundancyFactor int32 `json:"redundancy_factor,omitempty"`

	// List of connected clusters
	// Read Only: true
	RemoteConnections []*ClusterConnectionInfo `json:"remote_connections,omitempty"`

	// Map of installed softwares on the cluster with software type as the
	// key
	//
	SoftwareMap map[string]ClusterSoftware `json:"software_map,omitempty"`

	// ssl key
	// Read Only: true
	SslKey *SslKey `json:"ssl_key,omitempty"`

	// Verbosity level settings for populating support information.
	// - 'Nothing': Send nothing
	// - 'Basic': Send basic information - skip core dump and hypervisor
	//            stats information
	// - 'BasicPlusCoreDump': Send basic and core dump information
	// - 'All': Send all information
	//
	SupportedInformationVerbosity string `json:"supported_information_verbosity,omitempty"`

	// Zone name used in value of TZ environment variable
	Timezone string `json:"timezone,omitempty"`

	// type
	// Read Only: true
	Type ClusterType `json:"type,omitempty"`
}

// Validate validates this cluster config
func (m *ClusterConfig) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBuild(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCaCerts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCertificationSigningInfo(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateClientAuth(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateEnabledFeatures(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateEncryptionStatus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateKeyManagementServers(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePublicKeys(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRemoteConnections(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSoftwareMap(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSslKey(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSupportedInformationVerbosity(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterConfig) validateBuild(formats strfmt.Registry) error {

	if swag.IsZero(m.Build) { // not required
		return nil
	}

	if m.Build != nil {

		if err := m.Build.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) validateCaCerts(formats strfmt.Registry) error {

	if swag.IsZero(m.CaCerts) { // not required
		return nil
	}

	for i := 0; i < len(m.CaCerts); i++ {

		if swag.IsZero(m.CaCerts[i]) { // not required
			continue
		}

		if m.CaCerts[i] != nil {

			if err := m.CaCerts[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) validateCertificationSigningInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.CertificationSigningInfo) { // not required
		return nil
	}

	if m.CertificationSigningInfo != nil {

		if err := m.CertificationSigningInfo.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) validateClientAuth(formats strfmt.Registry) error {

	if swag.IsZero(m.ClientAuth) { // not required
		return nil
	}

	if m.ClientAuth != nil {

		if err := m.ClientAuth.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

var clusterConfigEnabledFeaturesItemsEnum []interface{}

func (m *ClusterConfig) validateEnabledFeaturesItemsEnum(path, location string, value string) error {
	if clusterConfigEnabledFeaturesItemsEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["LOCK_DOWN_ENABLED","PASSWORD_REMOTE_LOGIN_ENABLED","SHADOW_CLONES_ENABLED","COMMON_CRITERIA_MODE_ENABLED","SSP_CONFIGURED"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			clusterConfigEnabledFeaturesItemsEnum = append(clusterConfigEnabledFeaturesItemsEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, clusterConfigEnabledFeaturesItemsEnum); err != nil {
		return err
	}
	return nil
}

func (m *ClusterConfig) validateEnabledFeatures(formats strfmt.Registry) error {

	if swag.IsZero(m.EnabledFeatures) { // not required
		return nil
	}

	for i := 0; i < len(m.EnabledFeatures); i++ {

		// value enum
		if err := m.validateEnabledFeaturesItemsEnum("enabled_features"+"."+strconv.Itoa(i), "body", m.EnabledFeatures[i]); err != nil {
			return err
		}

	}

	return nil
}

func (m *ClusterConfig) validateEncryptionStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.EncryptionStatus) { // not required
		return nil
	}

	if m.EncryptionStatus != nil {

		if err := m.EncryptionStatus.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *ClusterConfig) validateKeyManagementServers(formats strfmt.Registry) error {

	if swag.IsZero(m.KeyManagementServers) { // not required
		return nil
	}

	for i := 0; i < len(m.KeyManagementServers); i++ {

		if swag.IsZero(m.KeyManagementServers[i]) { // not required
			continue
		}

		if m.KeyManagementServers[i] != nil {

			if err := m.KeyManagementServers[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) validatePublicKeys(formats strfmt.Registry) error {

	if swag.IsZero(m.PublicKeys) { // not required
		return nil
	}

	for i := 0; i < len(m.PublicKeys); i++ {

		if swag.IsZero(m.PublicKeys[i]) { // not required
			continue
		}

		if m.PublicKeys[i] != nil {

			if err := m.PublicKeys[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) validateRemoteConnections(formats strfmt.Registry) error {

	if swag.IsZero(m.RemoteConnections) { // not required
		return nil
	}

	for i := 0; i < len(m.RemoteConnections); i++ {

		if swag.IsZero(m.RemoteConnections[i]) { // not required
			continue
		}

		if m.RemoteConnections[i] != nil {

			if err := m.RemoteConnections[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ClusterConfig) validateSoftwareMap(formats strfmt.Registry) error {

	if swag.IsZero(m.SoftwareMap) { // not required
		return nil
	}

	if err := validate.Required("software_map", "body", m.SoftwareMap); err != nil {
		return err
	}

	return nil
}

func (m *ClusterConfig) validateSslKey(formats strfmt.Registry) error {

	if swag.IsZero(m.SslKey) { // not required
		return nil
	}

	if m.SslKey != nil {

		if err := m.SslKey.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

var clusterConfigTypeSupportedInformationVerbosityPropEnum []interface{}

const (
	clusterConfigSupportedInformationVerbosityNOTHING           string = "NOTHING"
	clusterConfigSupportedInformationVerbosityBASIC             string = "BASIC"
	clusterConfigSupportedInformationVerbosityBASICPLUSCOREDUMP string = "BASIC_PLUS_CORE_DUMP"
	clusterConfigSupportedInformationVerbosityALL               string = "ALL"
)

// prop value enum
func (m *ClusterConfig) validateSupportedInformationVerbosityEnum(path, location string, value string) error {
	if clusterConfigTypeSupportedInformationVerbosityPropEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["NOTHING","BASIC","BASIC_PLUS_CORE_DUMP","ALL"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			clusterConfigTypeSupportedInformationVerbosityPropEnum = append(clusterConfigTypeSupportedInformationVerbosityPropEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, clusterConfigTypeSupportedInformationVerbosityPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *ClusterConfig) validateSupportedInformationVerbosity(formats strfmt.Registry) error {

	if swag.IsZero(m.SupportedInformationVerbosity) { // not required
		return nil
	}

	// value enum
	if err := m.validateSupportedInformationVerbosityEnum("supported_information_verbosity", "body", m.SupportedInformationVerbosity); err != nil {
		return err
	}

	return nil
}
