package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/validate"
)

// VMDefStatus VM Status Definition
//
// VM Status Definition
// swagger:model vm_def_status
type VMDefStatus struct {

	// backup policy
	BackupPolicy *VMDefStatusBackupPolicy `json:"backup_policy,omitempty"`

	// Reference to the cluster where this VM exists or needs to be migrated
	// to
	//
	ClusterReference ClusterReference `json:"cluster_reference,omitempty"`

	// A description or user annotation for the VM
	// Max Length: 1000
	Description string `json:"description,omitempty"`

	// VM Name
	// Required: true
	// Max Length: 140
	Name *string `json:"name"`

	// policies
	Policies Policies `json:"policies,omitempty"`

	// providers
	Providers Providers `json:"providers,omitempty"`

	// resources
	// Required: true
	Resources *VMDefStatusResources `json:"resources"`
}

// Validate validates this vm def status
func (m *VMDefStatus) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBackupPolicy(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateDescription(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateResources(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VMDefStatus) validateBackupPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.BackupPolicy) { // not required
		return nil
	}

	if m.BackupPolicy != nil {

		if err := m.BackupPolicy.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *VMDefStatus) validateDescription(formats strfmt.Registry) error {

	if swag.IsZero(m.Description) { // not required
		return nil
	}

	if err := validate.MaxLength("description", "body", string(m.Description), 1000); err != nil {
		return err
	}

	return nil
}

func (m *VMDefStatus) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	if err := validate.MaxLength("name", "body", string(*m.Name), 140); err != nil {
		return err
	}

	return nil
}

func (m *VMDefStatus) validateResources(formats strfmt.Registry) error {

	if err := validate.Required("resources", "body", m.Resources); err != nil {
		return err
	}

	if m.Resources != nil {

		if err := m.Resources.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

// VMDefStatusBackupPolicy Describes how and where to backup the VM
// swagger:model VMDefStatusBackupPolicy
type VMDefStatusBackupPolicy struct {

	// Consistency group to which this VM belongs to.
	// Pattern: ^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$
	ConsistencyGroupIdentifier string `json:"consistency_group_identifier,omitempty"`

	// snapshot policy
	SnapshotPolicy *SnapshotPolicy `json:"snapshot_policy,omitempty"`
}

// Validate validates this VM def status backup policy
func (m *VMDefStatusBackupPolicy) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateConsistencyGroupIdentifier(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSnapshotPolicy(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VMDefStatusBackupPolicy) validateConsistencyGroupIdentifier(formats strfmt.Registry) error {

	if swag.IsZero(m.ConsistencyGroupIdentifier) { // not required
		return nil
	}

	if err := validate.Pattern("backup_policy"+"."+"consistency_group_identifier", "body", string(m.ConsistencyGroupIdentifier), `^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$`); err != nil {
		return err
	}

	return nil
}

func (m *VMDefStatusBackupPolicy) validateSnapshotPolicy(formats strfmt.Registry) error {

	if swag.IsZero(m.SnapshotPolicy) { // not required
		return nil
	}

	if m.SnapshotPolicy != nil {

		if err := m.SnapshotPolicy.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

// VMDefStatusResources VM Resources
// swagger:model VMDefStatusResources
type VMDefStatusResources struct {

	// host reference
	HostReference *Reference `json:"host_reference,omitempty"`

	// The hypervisor type for the hypervisor the VM is hosted on
	HypervisorType string `json:"hypervisor_type,omitempty"`

	// Memory size in MB
	// Minimum: 1
	MemorySizeMb int32 `json:"memory_size_mb,omitempty"`

	// Number of cores per Vcpu
	// Minimum: 1
	NumCoresPerVcpu int32 `json:"num_cores_per_vcpu,omitempty"`

	// Number of Vcpus
	// Minimum: 1
	NumVcpus int32 `json:"num_vcpus,omitempty"`

	// Desired power state of the VM
	PowerState string `json:"power_state,omitempty"`

	// Virtual Disks attached to the VM
	VirtualDiskList []*VirtualDisk `json:"virtual_disk_list,omitempty"`

	// Virtual NICs attached to the VM
	VirtualNicList []*VirtualNic `json:"virtual_nic_list,omitempty"`
}

// Validate validates this VM def status resources
func (m *VMDefStatusResources) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateHostReference(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateHypervisorType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMemorySizeMb(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNumCoresPerVcpu(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNumVcpus(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePowerState(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVirtualDiskList(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVirtualNicList(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *VMDefStatusResources) validateHostReference(formats strfmt.Registry) error {

	if swag.IsZero(m.HostReference) { // not required
		return nil
	}

	if m.HostReference != nil {

		if err := m.HostReference.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

var vmDefStatusResourcesTypeHypervisorTypePropEnum []interface{}

const (
	vmDefStatusResourcesHypervisorTypeESX    string = "ESX"
	vmDefStatusResourcesHypervisorTypeHyperV string = "HyperV"
	vmDefStatusResourcesHypervisorTypeAHV    string = "AHV"
)

// prop value enum
func (m *VMDefStatusResources) validateHypervisorTypeEnum(path, location string, value string) error {
	if vmDefStatusResourcesTypeHypervisorTypePropEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["ESX","HyperV","AHV"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			vmDefStatusResourcesTypeHypervisorTypePropEnum = append(vmDefStatusResourcesTypeHypervisorTypePropEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, vmDefStatusResourcesTypeHypervisorTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *VMDefStatusResources) validateHypervisorType(formats strfmt.Registry) error {

	if swag.IsZero(m.HypervisorType) { // not required
		return nil
	}

	// value enum
	if err := m.validateHypervisorTypeEnum("resources"+"."+"hypervisor_type", "body", m.HypervisorType); err != nil {
		return err
	}

	return nil
}

func (m *VMDefStatusResources) validateMemorySizeMb(formats strfmt.Registry) error {

	if swag.IsZero(m.MemorySizeMb) { // not required
		return nil
	}

	if err := validate.MinimumInt("resources"+"."+"memory_size_mb", "body", int64(m.MemorySizeMb), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *VMDefStatusResources) validateNumCoresPerVcpu(formats strfmt.Registry) error {

	if swag.IsZero(m.NumCoresPerVcpu) { // not required
		return nil
	}

	if err := validate.MinimumInt("resources"+"."+"num_cores_per_vcpu", "body", int64(m.NumCoresPerVcpu), 1, false); err != nil {
		return err
	}

	return nil
}

func (m *VMDefStatusResources) validateNumVcpus(formats strfmt.Registry) error {

	if swag.IsZero(m.NumVcpus) { // not required
		return nil
	}

	if err := validate.MinimumInt("resources"+"."+"num_vcpus", "body", int64(m.NumVcpus), 1, false); err != nil {
		return err
	}

	return nil
}

var vmDefStatusResourcesTypePowerStatePropEnum []interface{}

const (
	vmDefStatusResourcesPowerStatePOWEREDON  string = "POWERED_ON"
	vmDefStatusResourcesPowerStatePOWEREDOFF string = "POWERED_OFF"
	vmDefStatusResourcesPowerStatePAUSED     string = "PAUSED"
	vmDefStatusResourcesPowerStateSUSPENDED  string = "SUSPENDED"
	vmDefStatusResourcesPowerStateRESETTING  string = "RESETTING"
)

// prop value enum
func (m *VMDefStatusResources) validatePowerStateEnum(path, location string, value string) error {
	if vmDefStatusResourcesTypePowerStatePropEnum == nil {
		var res []string
		if err := json.Unmarshal([]byte(`["POWERED_ON","POWERED_OFF","PAUSED","SUSPENDED","RESETTING"]`), &res); err != nil {
			return err
		}
		for _, v := range res {
			vmDefStatusResourcesTypePowerStatePropEnum = append(vmDefStatusResourcesTypePowerStatePropEnum, v)
		}
	}
	if err := validate.Enum(path, location, value, vmDefStatusResourcesTypePowerStatePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *VMDefStatusResources) validatePowerState(formats strfmt.Registry) error {

	if swag.IsZero(m.PowerState) { // not required
		return nil
	}

	// value enum
	if err := m.validatePowerStateEnum("resources"+"."+"power_state", "body", m.PowerState); err != nil {
		return err
	}

	return nil
}

func (m *VMDefStatusResources) validateVirtualDiskList(formats strfmt.Registry) error {

	if swag.IsZero(m.VirtualDiskList) { // not required
		return nil
	}

	for i := 0; i < len(m.VirtualDiskList); i++ {

		if swag.IsZero(m.VirtualDiskList[i]) { // not required
			continue
		}

		if m.VirtualDiskList[i] != nil {

			if err := m.VirtualDiskList[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *VMDefStatusResources) validateVirtualNicList(formats strfmt.Registry) error {

	if swag.IsZero(m.VirtualNicList) { // not required
		return nil
	}

	for i := 0; i < len(m.VirtualNicList); i++ {

		if swag.IsZero(m.VirtualNicList[i]) { // not required
			continue
		}

		if m.VirtualNicList[i] != nil {

			if err := m.VirtualNicList[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}
