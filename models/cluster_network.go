package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"

	"github.com/go-openapi/errors"
)

// ClusterNetwork Cluster Network Configuration
//
// Cluster network
// swagger:model cluster_network
type ClusterNetwork struct {

	// domain
	Domain *ClusterDomainServer `json:"domain,omitempty"`

	// The cluster IP address that provides external entities access to
	// various cluster data services
	//
	ExternalDataservicesIPAddress string `json:"external_dataservices_ip_address,omitempty"`

	// The local IP of cluster visible externally
	ExternalIPAddress string `json:"external_ip_address,omitempty"`

	// External subnet for cross server communication. The format is
	// IP/netmask
	//
	ExternalSubnet *string `json:"external_subnet,omitempty"`

	// List of proxies to connect to the service centers
	HTTPProxyList []*ClusterNetworkEntity `json:"http_proxy_list,omitempty"`

	// List of Http Proxy Whiltelist
	HTTPProxyWhitelist []*HTTPProxyWhitelist `json:"http_proxy_whitelist,omitempty"`

	// The internal subnet is local to every server - its not visible
	// outside.iSCSI requests generated internally within the appliance
	// (by user VMs or VMFS) are sent to the internal subnet. The format is
	// IP/netmask
	//
	InternalSubnet *string `json:"internal_subnet,omitempty"`

	// The cluster NAT'd or proxy IP which maps to the cluster local IP
	//
	MasqueradingIP string `json:"masquerading_ip,omitempty"`

	// Port used together with masquerading_ip to connect to the cluster
	//
	MasqueradingPort int32 `json:"masquerading_port,omitempty"`

	// The list of IP addresses of the name servers
	NameServerIPList []string `json:"name_server_ip_list,omitempty"`

	// Comma separated list of subnets (of the form 'a.b.c.d/l.m.n.o') that
	// are allowed to send NFS requests to this container. If not specified,
	// the global NFS whitelist will be looked up for access permission.
	// The internal subnet is always automatically considered part of the
	// whitelist, even if the field below does not explicitly specify it.
	// Similarly, all the hypervisor IPs are considered part of the
	// whitelist. Finally, to permit debugging, all of the SVMs local IPs
	// are considered to be implicitly part of the whitelist
	//
	NfsSubnetWhitelist []string `json:"nfs_subnet_whitelist,omitempty"`

	// The list of IP addresses or FQDNs of the NTP servers
	NtpServerIPList []string `json:"ntp_server_ip_list,omitempty"`

	// List of service centers that can be connected to
	ServiceCenterList []*ClusterNetworkEntity `json:"service_center_list,omitempty"`

	// smtp server
	SMTPServer *SMTPServer `json:"smtp_server,omitempty"`
}

// Validate validates this cluster network
func (m *ClusterNetwork) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateDomain(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateHTTPProxyList(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateHTTPProxyWhitelist(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNameServerIPList(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNfsSubnetWhitelist(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateNtpServerIPList(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateServiceCenterList(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSMTPServer(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *ClusterNetwork) validateDomain(formats strfmt.Registry) error {

	if swag.IsZero(m.Domain) { // not required
		return nil
	}

	if m.Domain != nil {

		if err := m.Domain.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}

func (m *ClusterNetwork) validateHTTPProxyList(formats strfmt.Registry) error {

	if swag.IsZero(m.HTTPProxyList) { // not required
		return nil
	}

	for i := 0; i < len(m.HTTPProxyList); i++ {

		if swag.IsZero(m.HTTPProxyList[i]) { // not required
			continue
		}

		if m.HTTPProxyList[i] != nil {

			if err := m.HTTPProxyList[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNetwork) validateHTTPProxyWhitelist(formats strfmt.Registry) error {

	if swag.IsZero(m.HTTPProxyWhitelist) { // not required
		return nil
	}

	for i := 0; i < len(m.HTTPProxyWhitelist); i++ {

		if swag.IsZero(m.HTTPProxyWhitelist[i]) { // not required
			continue
		}

		if m.HTTPProxyWhitelist[i] != nil {

			if err := m.HTTPProxyWhitelist[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNetwork) validateNameServerIPList(formats strfmt.Registry) error {

	if swag.IsZero(m.NameServerIPList) { // not required
		return nil
	}

	return nil
}

func (m *ClusterNetwork) validateNfsSubnetWhitelist(formats strfmt.Registry) error {

	if swag.IsZero(m.NfsSubnetWhitelist) { // not required
		return nil
	}

	return nil
}

func (m *ClusterNetwork) validateNtpServerIPList(formats strfmt.Registry) error {

	if swag.IsZero(m.NtpServerIPList) { // not required
		return nil
	}

	return nil
}

func (m *ClusterNetwork) validateServiceCenterList(formats strfmt.Registry) error {

	if swag.IsZero(m.ServiceCenterList) { // not required
		return nil
	}

	for i := 0; i < len(m.ServiceCenterList); i++ {

		if swag.IsZero(m.ServiceCenterList[i]) { // not required
			continue
		}

		if m.ServiceCenterList[i] != nil {

			if err := m.ServiceCenterList[i].Validate(formats); err != nil {
				return err
			}
		}

	}

	return nil
}

func (m *ClusterNetwork) validateSMTPServer(formats strfmt.Registry) error {

	if swag.IsZero(m.SMTPServer) { // not required
		return nil
	}

	if m.SMTPServer != nil {

		if err := m.SMTPServer.Validate(formats); err != nil {
			return err
		}
	}

	return nil
}
